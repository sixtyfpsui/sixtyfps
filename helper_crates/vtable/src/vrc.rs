/* LICENSE BEGIN
    This file is part of the SixtyFPS Project -- https://sixtyfps.io
    Copyright (c) 2020 Olivier Goffart <olivier.goffart@sixtyfps.io>
    Copyright (c) 2020 Simon Hausmann <simon.hausmann@sixtyfps.io>

    SPDX-License-Identifier: GPL-3.0-only
    This file is also available under commercial licensing terms.
    Please contact info@sixtyfps.io for more information.
LICENSE END */

//! implementation of vtable::Vrc

use core::cell::Cell;

use super::*;

/// This trait is implemented by the `#[vtable]` macro.
///
/// It is implemented if the macro has a "drop_in_place" function.
pub unsafe trait VTableMetaDropInPlace: VTableMeta {
    /// Safety: the target ptr argument needs to be pointing to a valid allocated pointer
    unsafe fn drop_in_place(vtable: &Self::VTable, ptr: *mut u8) -> vrc::Layout;
    unsafe fn dealloc(vtable: &Self::VTable, ptr: *mut u8, layout: vrc::Layout);
}

/// Similar to [`std::alloc::Layout`], but `repr(C)`
#[repr(C)]
#[derive(Clone, Copy)]
pub struct Layout {
    pub size: usize,
    pub align: usize,
}

impl From<core::alloc::Layout> for Layout {
    fn from(layout: core::alloc::Layout) -> Self {
        Self { size: layout.size(), align: layout.align() }
    }
}

impl core::convert::TryFrom<Layout> for core::alloc::Layout {
    type Error = core::alloc::LayoutErr;

    fn try_from(value: Layout) -> Result<Self, Self::Error> {
        Self::from_size_align(value.size, value.align)
    }
}

#[repr(C)]
struct VRcInner<'vt, T: VTableMeta, X> {
    vtable: &'vt T::VTable,
    strong_ref: Cell<u32>,
    weak_ref: Cell<u32>,
    data: X,
}

/// A reference counted pointer to an object matching the virtual table `T`
///
/// Similar to [`std::rc::Rc`] where T is a VTable struct. But it has the following difference with
/// the type from std:
/// - It doesn't implement `Deref`, but you need to call `borrow()` to access a `VRef<R>`
/// which implements `Deref`.
/// - It does not allow to access mutable reference. (No `get_mut` or `make_mut`), meaning it is
/// safe to get a Pin reference with `borrow_pin`.
/// - It is safe to pass it accross ffi boundaries.
#[repr(transparent)]
pub struct VRc<T: VTableMetaDropInPlace + 'static> {
    inner: NonNull<VRcInner<'static, T, u8>>,
}

impl<T: VTableMetaDropInPlace + 'static> Drop for VRc<T> {
    fn drop(&mut self) {
        unsafe {
            let inner = self.inner.as_ref();
            inner.strong_ref.set(inner.strong_ref.get() - 1);
            if inner.strong_ref.get() == 0 {
                let data = &inner.data as *const u8 as *mut u8;
                let layout = T::drop_in_place(inner.vtable, data);
                inner.weak_ref.set(inner.weak_ref.get() - 1);
                if inner.weak_ref.get() == 0 {
                    let vtable = inner.vtable;
                    T::dealloc(vtable, self.inner.cast().as_ptr(), layout);
                } else {
                    self.inner.cast::<VRcInner<T, Layout>>().as_mut().data = layout;
                }
            }
        }
    }
}

impl<T: VTableMetaDropInPlace> VRc<T> {
    /// Create a new VRc from an instance of a type that can be associated with a VTable.
    ///
    /// Will move the instance on the heap.
    ///
    /// (the `HasStaticVTable` is implemented by the `“MyTrait”VTable_static!` macro generated by
    /// the #[vtable] macro)
    pub fn new<X: HasStaticVTable<T>>(data: X) -> Self {
        let layout = core::alloc::Layout::new::<VRcInner<T, X>>();
        let other = core::alloc::Layout::new::<VRcInner<T, Layout>>();
        let layout = core::alloc::Layout::from_size_align(
            layout.size().max(other.size()),
            layout.align().max(other.align()),
        )
        .unwrap();
        let mem = unsafe { std::alloc::alloc(layout) as *mut VRcInner<T, X> };
        let inner = NonNull::new(mem).unwrap();
        assert!(!mem.is_null());

        unsafe {
            mem.write(VRcInner {
                vtable: X::static_vtable(),
                strong_ref: Cell::new(1),
                weak_ref: Cell::new(1),
                data,
            });
            VRc { inner: inner.cast() }
        }
    }

    /// Gets a VRef pointing to this instance
    pub fn borrow<'b>(&'b self) -> VRef<'b, T> {
        unsafe {
            let inner = self.inner.as_ref();
            VRef::from_raw(NonNull::from(inner.vtable), NonNull::from(&inner.data))
        }
    }

    /// Gets a Pin<VRef> pointing to this instance
    ///
    /// This is safe because there is no way to access a mutable reference to the pointee.
    /// (There is no `get_mut` or `make_mut`),
    pub fn borrow_pin<'b>(&'b self) -> Pin<VRef<'b, T>> {
        unsafe { Pin::new_unchecked(self.borrow()) }
    }

    /// Construct a [`VWeak`] pointing to this instance.
    pub fn downgrade(&self) -> VWeak<T> {
        let inner = unsafe { self.inner.as_ref() };
        inner.weak_ref.set(inner.weak_ref.get() + 1);
        VWeak { inner: Some(self.inner) }
    }
}

impl<T: VTableMetaDropInPlace + 'static> Clone for VRc<T> {
    fn clone(&self) -> Self {
        let inner = unsafe { self.inner.as_ref() };
        inner.strong_ref.set(inner.strong_ref.get() + 1);
        Self { inner: self.inner }
    }
}

/// Weak pointer for the [`VRc`] type
///
/// Similar to [`std::rc::Weak`] where T is a VTable struct.
///
/// Can be constructed with [`VRc::downgrade`] and use [`VWeak::upgrade`]
/// to re-create the original VRc.
#[repr(transparent)]
#[derive(Default)]
pub struct VWeak<T: VTableMetaDropInPlace + 'static> {
    inner: Option<NonNull<VRcInner<'static, T, u8>>>,
}

impl<T: VTableMetaDropInPlace + 'static> Clone for VWeak<T> {
    fn clone(&self) -> Self {
        if let Some(inner) = self.inner {
            let inner = unsafe { inner.as_ref() };
            inner.weak_ref.set(inner.weak_ref.get() + 1);
        }
        VWeak { inner: self.inner }
    }
}

impl<T: VTableMetaDropInPlace + 'static> Drop for VWeak<T> {
    fn drop(&mut self) {
        if let Some(i) = self.inner {
            let inner = unsafe { i.as_ref() };
            inner.weak_ref.set(inner.weak_ref.get() - 1);
            if inner.weak_ref.get() == 0 {
                let vtable = inner.vtable;
                unsafe {
                    let layout = i.cast::<VRcInner<T, Layout>>().as_ref().data;
                    T::dealloc(vtable, i.cast().as_ptr(), layout);
                }
            }
        }
    }
}

impl<T: VTableMetaDropInPlace> VWeak<T> {
    /// Returns a new `VRc` if some other instance still holds a strong reference to this item.
    /// Otherwise, returns None.
    pub fn upgrade(&self) -> Option<VRc<T>> {
        if let Some(i) = self.inner {
            let inner = unsafe { i.as_ref() };
            if inner.strong_ref.get() == 0 {
                None
            } else {
                inner.strong_ref.set(inner.strong_ref.get() + 1);
                Some(VRc { inner: i })
            }
        } else {
            None
        }
    }
}
